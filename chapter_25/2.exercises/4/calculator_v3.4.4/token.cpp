
#include "token.h"

//------------------------------------------------------------------------------

const string HELP_INSTR = "\n\nВводите выражения в формате: ЧИСЛО ОПЕРАТОР ЧИСЛО."
			"\nЧисла могут быть с любым знаком, целыми и с десятичной частью "
			"(ТОЧКА - десятичный разделитель). "
			"\nЛогические побитовые операторы (&, |, ^, ~) допустимо применять "
			" только к целочисленным аргументам со знаком."
			"\nДля завершения ввода (подтверждения) нажмите клавишу ENTER.\n\n"
			
			"Доступные операции:\n\n"
			"---------------------------------------------------\n"
			"|    +    |   -    |     *     |    /   |    %    |\n"
			"----------+--------+-----------+--------+---------|\n"
			"|         |        |           |        | остаток |\n"
			"| сложить | отнять |  умножить | делить |   от    |\n"
			"|         |        |           |        | деления |\n"
			"---------------------------------------------------\n"
			
			"------------------------------------------------------\n"
			"|   A & B   |   A | B   |    A ^ B    |    ~ЧИСЛО    |\n"
			"------------+-----------+-------------+--------------+\n"
			"| логическое| логическое| логич.побит.| логич.побит. |\n"
			"|  побитовое|  побитовое| Исключающее |  Дополнение  |\n"
			"|     И     |    ИЛИ    |  ИЛИ (XOR)  |(все 1=0, 0=1)|\n"
			"------------------------------------------------------\n"
			
			"-------------------------------------------------\n"
			"|   ()   |  pow(A,B) |   ЧИСЛО!  |  sqrt(ЧИСЛО) |\n"
			"---------+-----------+-----------+--------------|\n"
			"|        |  возвести |           |  квадратный  |\n"
			"| скобки | число A в | факториал |   корень из  |\n"
			"|        | степень B |           | полож. числа |\n"
			"-------------------------------------------------\n"
			
			"\nПример:\n> -2+(2*2) \n= 2\n\n"
			
			"В программе предусмотренны следующие константы (число Пи, число e и "
			"множитель тысяча):\n pi = 3.1415926535\n e = 2.7182818284\n k = 1000\n\n"
			
			"Имеется также возможность объявлять и применять свои переменные (#) "
			"и константы ($), которые задаются единожды без возможности изменения. "
			"Имя должно начинаться с буквы, может содержать буквы, цифры и символ '_'."
			"\nПример объявления переменной:\n> #var1=100 \n= 100\n"
			"\nПример изменения переменной:\n> var1 =5+.79 \n= 5.79\n"
			"\nПример объявления константы:\n> $ con_1 = 10 \n= 10\n"
			"\nПример применения:\n> var1-2 \n= 3.79\n\n"
			"   from ИМЯ_ФАЙЛА.ФОРМАТ - изменение потока ввода данных (можно заменить вновь на 'cin')\n"
			"   to ИМЯ_ФАЙЛА.ФОРМАТ - изменение потока вывода данных (можно заменить вновь на 'cout')\n"
			"   out - вывод всех констант и переменных в памяти программы\n"
			"   help - вызов справки\n   quit - для быстрого выхода\n\n"; //ИНСТРУКЦИИ

//------------------------------------------------------------------------------

//инициализация констант
/*Symbol_table::Symbol_table()
{
	vector_names.push_back( Variable("pi", 3.1415926535, true) );
	vector_names.push_back( Variable("e", 2.7182818284, true) );
	vector_names.push_back( Variable("k", 1000, true) );
}*/

void Symbol_table::table_out() //Вывод на экран всех констант и переменных подряд
{
	for (int i = 0; i < vector_names.size(); ++i) {
		cout << '\t' << i+1 << ". "; 
		
		if (vector_names[i].constant)		cout << "const ";
		else							cout << "var   ";
		
		cout << ' ' << vector_names[i].name << " = " << vector_names[i].value << ";\n";
	}
}

double Symbol_table::get(string s)
//получить значение существующей переменной
//на вход: имя переменной
//на выходе: значение переменной с указанным именем (если таковая существует)
{
	for (int i = 0; i < vector_names.size(); ++i)
		if (vector_names[i].name == s) return vector_names[i].value;
	
	error ("попытка получить значение необъявленной переменной ( Symbol_table::get() )");
}

void Symbol_table::set(string s, double d)
//изменить (установить) значение существующей переменной
//на вход: имя переменной и её новое значение
{
	for (int i = 0; i < vector_names.size(); ++i)
		if ( vector_names[i].constant && vector_names[i].name == s )
			error ("попытка изменить константу ( Symbol_table::set() )");
		
		else if ( vector_names[i].name == s ) {
			vector_names[i].value = d;
			return;
		}
	
	error ("попытка установить значение для необъявленной переменной ( Symbol_table::set() )");
}

bool Symbol_table::is_declared(string s)
//проверка существует ли уже переменная с таким именем
//на вход: имя переменной
//на выходе: true - если переменная с таким именем существует / false - если нет
{
	for (int i = 0; i < vector_names.size(); ++i)
		if ( vector_names[i].name == s )	return true;
	
	return false;
}

void Symbol_table::define(string name, double d, bool cnst)
//добавление не объявленной ранее переменной/константы в массив переменных
//на вход: имя несуществующей переменной, её значение и яв-ся ли она константой или нет (true - если да)
{
	//Если такой переменной/константы ещё не существует в массиве
	if ( is_declared(name) == false )
		vector_names.push_back(Variable(name, d, cnst));
	
	//Если переменная с таким именем уже существует..
	else
		error ("попытка объявления уже существующей переменной ( Symbol_table::define() )"); //..ошибка
		//set(string name, double d); //..изменяем её значение
}

//------------------------------------------------------------------------------

void Token_stream::ignore(char c)
//Символ 'c' представляет разновидность лексем
//отбрасывает все символы до указанного на входе в функцию, ничего не возвращает
{
	//Сначала проверяем буфер
	if (full && c == buffer.kind)
	{
		full = false;
		return;
	}
	
	//Затем проверяем входные данные
	Token_stream::full = false;
	char ch = 0;
	ist.clear();
	while(ist.get(ch))
		if(ch == c  ||  ch == ist.eof())		return;  // || ch == '\n'
}

//Член putback() помещает аргумент в буфер своей ф-ции Token_stream:
void Token_stream::putback(Token t)
{
	if(full)
		error("Ошибка ф-ции putback(): попытка заполнить уже полный буфер");

	buffer = t;		//копировать t в буфер
	full = true;	//теперь буфер полон
}

Token Token_stream::get()
{
	if (full) { //Если в буфере уже имеется объект типа Token..
		//..удаляем его из буфера (помечаем буфер как пустой, т.е. доступный для перезаписи)
		full = false;
		return buffer;
	}

	char ch = ' ';
	while( isspace(ch) && ch != PRINT && !ist.eof() )		ist.get(ch); //Съедаем пробелы
	
	if( ist.eof() )		return Token(QUIT);
	
	else if(ch == PRINT)	return Token(PRINT); //для завершения вычислений и немедленного вывода ответа на экран
	ist.unget();
	
	ist >> ch;		//замечание: оператор >> пропускает пустые пространства
					//(пробел, символ новой строки, табуляция и т.д.)
	switch (ch)
	{
		case LET: case CONSTANT: case '=': //переменные и константы
		case ',': //разделитель аргументов при возведении в степень
		case '!': //факториал
		case '(': case ')':
		case '&': case '|': case '^': case '~': //логические операции И, ИЛИ, Исключающее ИЛИ, Дополнение
		case '+': case '-': case '*': case '/': case '%':
			return Token(ch);			//Каждый символ представляет сам себя
		
		case '.': //Число с плавающей зпт может начинаться с точки
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		{
			ist.unget();	//возврат каретки на 1 символ назад
			
			double val;
			ist >> val;		//считываем число с плавающей ЗПТ
			if(!ist)		{ ist.clear();		error("недопустимый ввод ( Token_stream::get() )"); }
			
			return Token(NUMBER, val);	//помечаем объект символом '8' означающим "число"
		}
		
		default:
		{
			string str = "";
			
			if ( isalpha(ch) ){ //Если первый символ - буква (имя может начинаться только с буквы)
				str += ch;
				
				while (ist.get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
									   //буква,          цифра    или нижнее подчеркивание
					str += ch;
				
				ist.unget(); //возврат каретки на 1 символ назад, т.к. он не имеет отношения к имени
				
				if		(str == HELPKEY)			return Token(HELP);
				else if (str == QUITKEY)			return Token(QUIT);
				else if (str == POWKEY)				return Token(POW);
				else if (str == SQRTKEY)			return Token(SQRT);
				else if (str == TABLEOUTKEY)		return Token(TABLEOUT);
				else if (str == CHANGEINPUTKEY)		return Token(CHANGEINPUT);
				else if (str == CHANGEOUTPUTKEY)	return Token(CHANGEOUTPUT);
				
				return Token(VARIABLE, str);
			}
			
			ist.clear();
			error("недопустимый ввод ( Token_stream::get() )");
		}
	}
}

//------------------------------------------------------------------------------