1. Выполните упражнения из разделов "Попробуйте", если вы этого еще не сделали.

2. Составьте список слов, которые можно получить и з записи чисел в шестнадцатеричной системе счисления, читая 0 как о, 1 как l, 2 как to и т.д. Например, Fool и Beef. Прежде чем сдать их для оценки, тщательно устраните все вульгаризмы.

3. Проинициализируйте 32-битовое целое число со знаком указанной битовой последовательностью и выведите его на экран: все биты нулевые, все биты единичные, чередующиеся нули и единицы (крайний слева бит - единичный), чередующиеся нули и единицы (крайний слева бит - нулевой), шаблон 1100110011..., 0011001100..., чередующиеся байты, состоящие только из единичных и только из нулевых битов, начиная с байта, состоящего из одних нулей. Повторите это упражнение с 32-битовым целым числом без знака.

4. Добавьте в калькулятор из главы 7 побитовые логические операторы &, |, ^ и ~.

5. Напишите бесконечный цикл. Выполните его.

6. Напишите бесконечный цикл, который трудно распознать как бесконечный. Годится также цикл, который на самом деле не является бесконечным,
потому что закончится после исчерпания ресурса.

7. Выведите шестнадцатеричные значения от 0 до 400; выведите шестнадцатеричные значения от -200 до 200.

8. Выведите числовой код каждого символа на своей клавиатуре.

9. Не используя ни стандартные заголовочные файлы (такие как <limits>), ни документацию, вычислите количество битов в типе int и определите, имеет ли знак тип char в вашей реализации языка С++.

10. Взгляните на пример битового поля из раздела 25.5.5. Напишите пример, в котором сначала инициализируется структура PPN, затем считывается и выводится на экран значение каждого ее поля, затем значение каждого поля изменяется (с помощью присваивания) и результат выводится на экран. Повторите это упражнение, сохраняя информацию из структуры PPN в 32-битовом целом числе без знака и используя операторы для работы с битами (см. раздел 25.5.4) для доступа к отдельным битам слова.

11. Повторите предыдущее упражнение, сохраняя биты в объекте класса bitset<32>.

12. Напишите понятную программу для примера из раздела 25.5.6.

13. Используйте алгоритм ТЕА (см. раздел 25.5.6) для "безопасной" передачи данных между двумя компьютерами. Использовать электронную почту настоятельно не рекомендуется. (ФАЙЛ-пример "in.txt" для расшифровки по ключу 'bs' лежит рядом с исходником)

14. Реализуйте простой вектор, в котором могут храниться не более N элементов, память для которых выделяется из пула. Протестируйте его при N==1000 и целочисленных элементах.

15. Измерьте время (см. раздел 26.6.1), которое затрачивается на размещение 10 тысяч объектов случайного размера в диапазоне (0; 1000] байтов с помощью оператора new; затем измерьте время, которое будет затрачено на удаление этих элементов с помощью оператора delete.
Сделайте это дважды: один раз освобождая память в обратном порядке, второй раз - случайным образом. Затем выполните то же задание для 10 тысяч объектов размером 500 байтов, выделяя и освобождая память в пуле. После этого разместите 10 тысяч объектов случайного размера в диапазоне (0; 1000] байтов, выделяя память в стеке и освобождая ее (в обратном порядке). Сравните результаты измерений. Выполните каждое измерение не менее трех раз, чтобы убедиться в согласованности результатов.

16. Сформулируйте двадцать правил, регламентирующих стиль кодирования (не копируя правила из раздела 25.6). Примените их к программе, состоящей более чем из 300 строк, которую вы недавно написали. Напишите короткий (на одной-двух страницах) комментарий о применении этих правил. Нашли ли вы ошибки в программе? Стал ли код яснее? Может быть, он стал менее понятным? Теперь модифицируйте набор правил, основываясь на своем опыте.

17. В разделах 25.4.3-25.4.4 мы описали класс Array_ref, делающий доступ к элементам массива более простым и безопасным. В частности, мы заявили, что теперь наследование обрабатывается корректно. Испытайте разные способы получения указателя Rectangle* на элемент массива vector<Circle*>, используя класс Array_ref<Shape*>, но не прибегая к приведению типов и другим операциям с непредсказуемым поведением. Это должно оказаться невозможным.