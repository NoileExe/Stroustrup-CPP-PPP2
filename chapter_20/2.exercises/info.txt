1. Если вы еще не выполнили задания из врезок Попробуйте, то сделайте это сейчас.

2. Попробуйте запрограммировать пример с Джеком и Джилл из раздела 20.1.2. Для тестирования используйте несколько небольших файлов. (ФАЙЛЫ "jack.txt" и "jill.txt" лежат рядом с исходником и должны находится рядом с исполняемым файлом перед его запуском)

3. Проанализируйте пример с палиндромом (см. раздел 18.7); еще раз выполните задание из п.2, используя разные приемы. (ФАЙЛЫ "jack.txt" и "jill.txt" лежат рядом с исходником и должны находится рядом с исполняемым файлом перед его запуском)

4. Найдите и исправьте ошибки, сделанные в примере с Джеком и Джилл в разделе 20.3.1, используя приемы библиотеки STL. (ФАЙЛЫ "jack.txt" и "jill.txt" лежат рядом с исходником и должны находится рядом с исполняемым файлом перед его запуском)

5. Определите операторы ввода и вывода (>> и <<) для класса vector. (ФАЙЛЫ "jack.txt" и "jill.txt" лежат рядом с исходником и должны находится рядом с исполняемым файлом перед его запуском)

6. Напишите операцию "найти и заменить" для класса Document, используя информацию из раздела 20.6.2. (ФАЙЛ "input.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

7. Определите лексикографически последнюю строку в неупорядоченном классе vector<string>. (ФАЙЛ "input.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

8. Напишите функцию, подсчитывающую количество символов в объекте класса Document. (ФАЙЛ "input.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

9. Напишите программу, подсчитывающую количество слов в объекте класса Document. Предусмотрите две версии: одну, в которой слово - это "последовательность символов, разделенных пробельными символами", и вторую, в которой слово - это "неразрывная последовательность алфавитных символов". Например, при первом определении выражения alpha.numeric и as12b это слова, а при втором каждое из них рассматривается как два слова. (ФАЙЛ "input.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

10. Напишите подсчитывающую слова программу, в которой пользователь мог бы сам задавать набор символов-разделителей. (ФАЙЛ "input.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

11. Создайте объект класса vector<double> и скопируйте в него элементы списка типа list<int>, передавая его как параметр (по ссылке). Убедитесь, что копия полна и верна. Затем выведите на экран элементы в порядке возрастания их значений.

12. Завершите определение класса list из разделов 20.4.1 и 20.4.2 и продемонстрируйте работу функции high(). Выделите память для объекта класса Link, представляющего узел, следующий за концом списка.

13. На самом деле в классе list нам не нужен реальный объект класса Link, расположенный за последним элементом. Модифицируйте свое решение из предыдущего упражнения так, чтобы в качестве указателя на несуществующий объект класса Link (list<Elem>::end() ) использовалось значение 0; иначе говоря, размер пустого списка может быть равен размеру отдельного указателя.

14. Определите односвязный список slist, ориентируясь на стиль класса std::list. Какие операции из класса list стоило бы исключить из класса slist, поскольку он не содержит указателя на предыдущий элемент?

15. Определите класс pvector, похожий на вектор указателей, с тем отличием, что он содержит указатели на объекты, а его деструктор уничтожает все объекты, на которые указывают указатели-элементы.

16. Определите класс ovector, похожий на класс pvector, с тем отличием, что операции [ ] и * возвращают не указатели, а ссылки на объекты, на которые указывают соответствующие элементы.

17. Определите класс ownership_vector, хранящий указатели на объект, как и класс pvector, но предусматривающий механизм, позволяющий пользователю решить, какие из объектов принадлежат вектору (т.е. какие объекты должны быть удалены деструктором класса). Указание: это простое упражнение, если вы вспомните главу 13.

18. Определите итератор с проверкой выхода за пределы допустимого диапазона для класса vector (итератор с произвольным доступом).

19. Определите итератор с проверкой выхода за пределы допустимого диапазона для класса list (двунаправленный итератор).

20. Проведите эксперимент по сравнению временных затрат при работе с классами vector и list. Способ измерения длительности работы программы изложен в разделе 26.6.1. Сгенерируйте N случайных целых чисел в диапазоне [0,N). Вставьте каждое сгенерированное число в вектор vector<int> (после каждой вставки увеличивающийся на один элемент). Поддерживайте вектор в отсортированном виде: иначе говоря, значение должно быть вставлено так, чтобы все предыдущие значения были меньше или равны ему, а все последующие значения должны быть больше него. Выполните те же действия, используя для хранения целых чисел класс list<int>. При каких значениях N класc list обеспечивает более высокое быстродействие, чем класс vector? Попробуйте объяснить результаты эксперимента. Впервые этот эксперимент был предложен Джоном Бентли (John Bentley).