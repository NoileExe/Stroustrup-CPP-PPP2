В каждом из упражнений создайте и проверьте (с выводом на печать) набор объектов определенных классов и продемонстрируйте, что ваш проект и реализация действительно работают так, как вы ожидали. Там, где задействованы исключения, может потребоваться тщательное обдумывание мест, где могут появиться ошибки.


1. Напишите шаблонную функцию f(), складывающую элементы одного вектора vector<T> с элементами другого такого вектора; например, f(vl, v2) должна выполнять суммирование v1[i] += v2[i] для каждого элемента v1.

2. Напишите шаблонную функцию, получающую в качестве аргументов объекты типов vector<T> vt и vector<U> vu и возвращающую сумму всех произведений vt[i] * vu[i].

3. Напишите шаблонный класс Pair, содержащий пары значений любого типа. Используйте его для реализации простой таблицы символов, такой как в калькуляторе из раздела 7.8.

4. Превратите класс Link из раздела 17.9.З в шаблонный, в котором аргументом типа является тип элемента. Затем выполните заново упр.13 из главы 17 с классом Link<God>.

5. Определите класс Int, содержащий единственный член типа int. Определите конструкторы, оператор присваивания и операторы +, -, * и /.  Протестируйте этот класс и при необходимости усовершенствуйте его дизайн (например, определите операторы << и >> для удобства ввода-вывода).

6. Повторите предыдущее упражнение с классом Number<T>, где T может быть любым числовым типом. Попытайтесь добавить в класс Number оператор % и посмотрите, что произойдет, когда вы попробуете применить оператор % к типам Number<double> и Number<int>.

7. Примените решение упр.2 к нескольким объектам типа Number.

8. Реализуйте распределитель памяти (см. раздел 19.3.7), используя функции malloc() и free() (раздел Б.11.4). Создайте класс vector так, как описано в конце раздела 19.4, для работы с несколькими простыми тестовыми примерами. Указание: поищите "размещающий new" и "явный вызов деструктора" в полном справочнике по С++.

9. Повторите реализацию функции vector::operator=() (раздел 19.2.5), используя распределитель памяти (раздел 19.3.7) для управления памятью.

10. Реализуйте простой класс unique_ptr, содержащий только конструктор, деструктор, операторы -> и *, а также функцию release(). В частности, не пытайтесь реализовать присваивание или копирующий конструктор.

11. Разработайте и реализуйте указатель counted_ptr<T>, владеющий указателем на объект типа T, и указатель на "счетчик ссылок" (типа int), совместно используемый всеми указателями на один и тот же объект типа T. Счетчик ссылок должен содержать количество указателей, указывающих на данный объект типа T. Конструктор counted_ptr должен размещать в динамической памяти объект типа T и счетчик ссылок. Конструктор counted_ptr должен получать аргумент, используемый в качестве начального значения указателя на элемент типа T.
После уничтожения последнего объекта counted_ptr для данного объекта типа T его деструктор должен удалить этот объект. Предусмотрите в классе counted_ptr операции, позволяющие использовать его как указатель. Это пример так называемого "интеллектуального указателя", который используется для того, чтобы гарантировать, что объект не будет уничтожен, пока последний пользователь не закончит его использовать.
Напишите набор тестов для класса counted_ptr, используя его объекты в качестве аргументов при вызове функций, в качестве элементов контейнеров и т.д.

12. Определите класс File_handle, конструктор которого получает аргумент типа string (имя файла) и открывает файл, а деструктор закрывает этот файл. (ФАЙЛ "file.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

13. Напишите класс Tracer, в котором конструктор и деструктор выводят на экран строки. Передайте эти строки конструктору в качестве аргументов. Используйте этот пример для того, чтобы посмотреть, как работает идиома RAII (например, поэкспериментируйте с объектами класса Tracer в качестве локальных объектов, объектов-членов класса, глобальных объектов, объектов, размещенных в динамической памяти с помощью оператора new, и т.д. Затем добавьте копирующий конструктор и копирующее присваивание, чтобы можно было увидеть поведение объектов класса Tracer в процессе копирования).

14. Разработайте графический пользовательский интерфейс и средства вывода для игры "Охота на Вампуса" (см. главу 18). Предусмотрите ввод данных из окна редактирования и вывод в окне карты той части пещеры, которая в настоящий момент известна игроку.

15. Модифицируйте программу из предыдущего упражнения, чтобы дать пользователю возможность помечать комнаты, основываясь на знаниях и догадках, таких как "могут быть летучие мыши" и "бездонная пропасть".

16. Иногда желательно, чтобы пустой вектор был как можно более маленьким. Например, кто-то может интенсивно использовать класс "vector <vector<vector<int>>>", в котором большинство векторов пусто. Определите вектор так, чтобы выполнялось условие sizeof(vector<int>) == sizeof(int*), т.е. чтобы класс вектора состоял только из указателя на представление, в котором содержатся массив элементов, количество элементов и указатель space.