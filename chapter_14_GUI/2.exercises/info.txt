1. Определите два класса, Smiley (веселый) и Frowny (хмурый), производные от класса Circle и имеющие два глаза и рот. Затем создайте классы, производные от классов Smiley и Frowny, добавляющие к каждому из них соответствующую шляпу.

2. Попытайтесь скопировать объект класса Shape. Что произошло?

3. Определите абстрактный класс и попытайтесь определить объект его типа. Что произошло?

4. Определите класс Immobile_Circle, который во всем похож на класс Circle, но объекты которого не способны перемещаться.

5. Определите класс Striped_rectangle, в котором вместо заполнения прямоугольник заштриховывается горизонтальными линиями толщиной в один пиксель (например, рисуя линии через один пиксель). Поэкспериментируйте с толщиной линий и расстоянием между ними, чтобы
добиться желаемого эффекта.

6. Определите класс Striped_circle, используя приемы из класса Striped_rectangle.

7. Определите класс Striped_closed_polyline, используя приемы из класса Striped_rectangle (для этого придется потрудиться всерьез).

8. Определите класс Octagon, реализующий правильный восьмиугольник. Напишите тестовую программу, вызывающую все его функции-члены (как определенные вами, так и унаследованные от класса Shape).

9. Определите класс Group, служащий контейнером объектов класса Shape с соответствующими операциями над членами класса Group. Указание: Vector_ref. Используя класс Group, определите класс, рисующий шахматную доску, по которой под управлением программы могут перемещаться шашки.

10. Определите класс Pseudo_window, напоминающий класс Window. Постарайтесь не прилагать героических усилий. Он должен иметь закругленные углы, метку и управляющие пиктограммы. Возможно, вы сможете добавить какое-нибудь фиктивное содержание, например, изображение. На самом деле с этим изображением ничего не надо делать. Допускается (и даже рекомендуется), чтобы это окно располагалось в окне Simple_window. . (ФАЙЛ "my_img.jpg" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

11. Определите класс Binary_tree, производный от класса Shape. Задайте параметр, задающий количество уровней (levels==0 означает, что в дереве нет ни одного узла, levels==1 означает, что в дереве есть один узел, levels==2 означает, что дерево состоит из вершины и двух узлов, levels=3 означает, что дерево состоит из вершины и двух дочерних узлов, которые, в свою очередь, имеют по два дочерних узла, и т.д.). Пусть узел изображается маленьким кружочком. Соедините узлы линиями (как это принято).
P.S. В компьютерных науках деревья изображаются растущими вниз от вершины (забавно, что ее часто называют корнем, хотя это и логично).

12. Модифицируйте класс Binary_tree так, чтобы он рисовал свои узлы с помощью виртуальной функции. Затем унаследуйте от класса Binary_tree новый класс, в котором эта виртуальная функция перекрывается так, что узлы изображаются иначе (например, в виде треугольников).

13. Модифицируйте класс Binary_tree так, чтобы он получал параметр (или параметры), указывающие, какой вид линии используется для соединения узлов (например, стрелка, направленная вниз, или красная стрелка, направленная вверх). Обратите внимание, как в этом и последнем упражнениях используются два альтернативных способа, позволяющих сделать иерархию классов более гибкой и полезной.

14. Добавьте в класс Binary_tree операцию, добавляющую к узлу текст. Для того чтобы сделать это элегантно, можете модифицировать проект класса Binary_tree. Выберите способ идентификации узла; например, для перехода налево, направо, направо, налево и направо вниз по бинарному дереву можете использовать строку " lrrlr" (корневой узел может соответствовать как первому символу "1", так и первому символу "r").

15. Большинство иерархий классов не связано с графикой. Определите класс Iterator, содержащий чисто виртуальную функцию next(). возвращающую указатель типа double* (см. главу 17). Теперь унаследуйте от класса Iterator классы Vector_iterator и List_iterator так, чтобы функция next() для класса Vector_iterator возвращала указатель на следующий элемент вектора типа vector<double>, а для класса List_iterator  делала то же самое для списка типа list<double>. Инициализируйте объект класса Vector_iterator вектором vector<double>, и первый вызов функции next() должен возвращать указатель на первый элемент вектора, если таковой существует. Если такого элемента нет, верните нуль. Проверьте этот класс с помощью функции void print(Iterator&) , выводящей на печать элементы вектора типа vector<double> и списка типа list<double>.

16. Определите класс Controller, содержащий четыре виртуальные функции: on(), off(), set_level(int) и show(). Породите из класса Controller как минимум два класса. Один из них должен быть простым тестовым классом, в котором функция show() выводит на печать информацию о том, включен или выключен контроллер, а также его текущий уровень. Второй производный класс должен управлять цветом линий объекта класса Shape; точный смысл понятия "уровень" определите сами. Попробуйте найти третий объект для управления с помощью класса Controller.

17. Исключения, определенные в стандартной библиотеке языка С++, такие как exception, runtime_error и out_of_range (см. раздел 5.6.3), организованы в виде иерархии классов (с полезной виртуальной функцией what(), возвращающей строку, которая предположительно содержит объяснение происшедшей ошибки). Найдите источники информации об иерархии стандартных исключений в языке С++ и нарисуйте диаграмму этой иерархии классов.