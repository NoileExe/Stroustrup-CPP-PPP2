К сожалению, мы не можем сформулировать задание, которое выявило бы понимание общих принципов проектирования, поэтому решили сосредоточиться на свойствах языка, поддерживающих объектно-ориентированное программирование.


1. Определите класс B1 с виртуальной функцией vf() и невиртуальной функцией f(). Определите эти функции в классе B1. Реализуйте каждую функцию так, чтобы она выводила свое имя (например, "B1::vf()"). Сделайте эти функции открытыми. Создайте объект B1 и вызовите каждую из функций.

2. Определите класс D1, производный от класса B1, и перекройте в нем функцию vf(). Создайте объект класса D1 и вызовите из него функции vf() и f().

3. Определите ссылку на объект класса B1 (т.е. B1&) и инициализируйте ее только что созданным объектом класса D1. Вызовите функции vf() и f() с помощью этой ссылки.

4. Теперь определите функцию f() в классе D1 и повторите пп.1-3. Объясните результаты.

5. Добавьте в класс B1 чисто виртуальную функцию pvf() и попытайтесь повторить пп.1-4. Объясните результат.

6. Определите класс D2, производный от класса D1, и перекройте в нем функцию pvf(). Создайте объект класса D2 и вызовите из него функции f(), vf() и pvf().

7. Определите класс B2 с чисто виртуальной функцией pvf(). Определите класс D21 с данным-членом типа string и функцией-членом, перекрывающей функцию pvf(); функция D21::pvf() должна выводить значение упомянутого выше члена типа string. Определите класс D22, аналогичный классу D21, за исключением того, что его член имеет тип int. Определите функцию f(), получающую аргумент типа B2& и вызывающую функцию pvf() для этого аргумента. Вызовите функцию f() с аргументами D21 и D22.