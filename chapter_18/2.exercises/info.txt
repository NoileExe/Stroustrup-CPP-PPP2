1. Напишите функцию char*strdup (const char*), копирующую С-строку в динамическую память, которую она выделяет для этой копии строки. Не используйте никаких стандартных функций. Не используйте индексирование, вместо него применяйте оператор разыменования *·

2. Напишите функцию "char* findx(const char*s, const char*x)", находящую первое вхождение С-строки х в С-строку s. Не используйте никаких стандартных функций. Не используйте индексирование, вместо него применяйте оператор разыменования *.

3. Напишите функцию int strcmp (const char*s1, const char*s2), сравнивающую две С-строки. Если в лексикографическом порядке строка s1 меньше строки s2, функция должна возвращать отрицательное число, если строки совпадают - нуль, а если строка s1 больше строки s2 - положительное число. Не используйте никаких стандартных функций. Не используйте индексирование, вместо него применяйте оператор разыменования *.

4. Что случится, если передать функциям strdup(), findx() и strcmp() аргумент, не являющийся С-строкой? Попробуйте! Сначала необходимо выяснить, как получить указатель char*, который не указывает на массив символов, завершающийся нулем, а затем применить его (никогда не делайте этого в реальном - не экспериментальном - коде; это может привести к катастрофе). Поэкспериментируйте с "неправильными С-строками" в динамической памяти или стеке. Если результаты будут выглядеть разумно, отключите режим отладки. Переделайте и заново выполните все три функции так, чтобы они получали еще один аргумент - максимально допустимое количество символов в передаваемой строке. Затем протестируйте функции с правильными и неправильными С-строками.

5. Напишите функцию string cat_dot (const string&s1, const string&s2), выполняющую конкатенацию двух строк с точкой между ними. Например, вызов саt_dоt ("Нильс", "Бор") должен вернуть строку Нильс.Бор.

6. Модифицируйте функцию cat_dot() из предыдущего упражнения так, чтобы в качестве третьего аргумента она получала строку, используемую как разделитель (вместо точки).

7. Напишите варианты функции саt_dot() из предыдущих упражнений, получающие в качестве аргументов С-строки и возвращающие С-строку, размещенную в динамической памяти. Не используйте никаких функций или типов из стандартной библиотеки. Протестируйте эти функции на нескольких строках. Убедитесь, что вся память, выделенная с помощью оператора new, освобождается с помощью оператора delete. Сравните усилия, затраченные вами на выполнение упр. 5 и 6.

8. Перепишите все функции из раздела 18.7, используя для сравнения обращенную копию строки: например. введите строку "home", из нее сгенерируйте строку "emoh" и сравните эти две строки, чтобы убедиться, что слово home - не палиндром.

9. Проанализируйте схему распределения памяти, описанную в разделе 17.4. Напишите программу, сообщающую, в каком порядке располагаются статическая память, стек и динамическая память. В каком направлении растет стек: в сторону старших или младших адресов? Допустим, массив расположен в динамической памяти. Какой элемент будет иметь больший адрес - с большим индексом или с меньшим?

10. Проанализируйте решение задачи о палиндроме из раздела 18.7.2 с использованием массива. Исправьте его так, чтобы можно было работать с длинными строками:
	1) выдавайте сообщение, если введенная строка оказалась слишком длинной;
	2) разрешите использовать произвольно длинные строки. Прокомментируйте сложность обеих версий.

11. Разберитесь, что собой представляет список с пропусками (skip list), и реализуйте эту разновидность списка. Это непростое упражнение!

12. Реализуйте версию игры "Hunt the Wumpus" ("Охота на Вампуса" или просто "Вамп"). Это простая (не графическая) компьютерная игра, изобретенная Грегори Джобом (Gregory Yob). Цель этой игры - найти довольно смышленого монстра, прячущегося в темном пещерном лабиринте. Ваша задача - убить вампуса с помощью лука и стрел. Кроме вампуса, пещера таит еще две опасности: бездонные ямы и гигантские летучие мыши. Если вы входите в комнату с бездонной ямой, то игра для вас закончена. Если вы входите в комнату с летучей мышью, то она вас хватает и перебрасывает в другую комнату. Если же вы входите в комнату с вампусом или он входит в комнату, где находитесь вы, он вас съедает. Входя в комнату, вы должны получить предупреждение о грозящей опасности.
"Я чувствую запах вампуса" значит, что он в соседней комнате.
"Я чувствую ветерок" значит, что в соседней комнате яма.
"Я слышу летучую мышь" значит, что в соседней комнате живет летучая мышь.
Для вашего удобства комнаты пронумерованы. Каждая комната соединена туннелями с тремя другими. Когда вы входите в комнату, то получаете сообщение, например "Вы в комнате номер 12; отсюда идут туннели в комнаты 1, 13 и 4: идти или стрелять?" Возможны ответы наподобие m13 ("Переход в комнату номер 13") или s13-4-3 ("Стрелять через комнаты с номерами 13, 4 и 3"). Стрела может пролететь через три комнаты. В начале игры у вас есть пять стрел. Загвоздка со стрельбой заключается в том, что вы можете разбудить вампуса и он войдет в комнату, соседнюю с той, в которой он спал, а она может оказаться вашей комнатой.
Вероятно, самой сложной частью этого упражнения является программирование пещеры и выбор комнат, связанных с другими комнатами. Возможно, вы захотите использовать датчик случайных чисел (например, функцию randint() из std_lib_facilities.h), чтобы при разных запусках программы использовались разные пещеры и разное расположение летучих мышей и вампуса.
Указание: обеспечьте способ отладочного вывода состояния лабиринта.