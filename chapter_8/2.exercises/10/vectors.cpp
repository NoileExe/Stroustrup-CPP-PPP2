#include "vectors.h"

//------------------------------------------------------------------------------

struct_minmaxmid search_4m (const vector<double>& v)
//Инициализирует структуру struct_minmaxmid состоящую из 4 переменных double
//по сути вычисляет для непустого ветора мин., макс. числа, среднее арифм. и медиану
{
	struct_minmaxmid s_mmmm;
	
	if (v.size()==0)
		error ("пустой вектор (search_4m)!!!");
	
	s_mmmm.min = minv_proc(v);
	s_mmmm.max = maxv_proc(v);
	s_mmmm.mid = midv_proc(v);
	s_mmmm.medi = mediv_proc(v);
	
	return s_mmmm;
}

//------------------------------------------------------------------------------

double minv_proc(const vector<double>& v)
//Поиск наименьшего элемента в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: наименьший элемент в векторе
{
	if (v.size()==0)
		error ("пустой вектор (minv)!!!");
	
	double min = v[0];
	for (int i = 0;  i < v.size(); ++i)
		if (v[i] < min)
			min = v[i];
	
	return min;
}

double maxv_proc(const vector<double>& v)
//Поиск наибольшего элемента в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: наибольший элемент в векторе
{
	if (v.size()==0)
		error ("пустой вектор (maxv)!!!");
	
	double max = v[0];
	for (int i = 0;  i < v.size(); ++i)
		if (v[i] > max)
			max = v[i];
	
	return max;
}

double midv_proc(const vector<double>& v)
//Вычисление среднего арифметического для ряда чисел в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: среднее арифметическое
{
	if (v.size()==0)
		error ("пустой вектор (midv)!!!");
	
	double middle = 0;
	for (int i = 0;  i < v.size(); ++i)
		middle += v[i];
	
	middle /= v.size();
	
	if (isinf(middle))
		error ("значение вышло за пределы типа DOUBLE (midv)!!!");
	else
		return middle;
}

double mediv_proc(vector<double> v)
//Вычисление медианы для ряда чисел в векторе
//На вход: непустой вектор (копия, чтобы не сортировать оригинальный)
//Возврат: медиана
{
	if (v.size()==0)
		error ("пустой вектор (mediv)!!!");
		
	sort( v.begin(), v.end() );
	
	double median = 0;
	int mid = int( v.size() / 2 );
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	
	if (v.size()%2 == 0) //четное кол-во элементов в векторе
		median = (v[mid]+v[mid+1])/2;
	else
		median = v[mid];
	
	if (isinf(median))
		error ("значение вышло за пределы типа DOUBLE (mediv)!!!");
	else
		return median;
}

//------------------------------------------------------------------------------

double common_check (const vector<double>& price, const vector<double>& count)
//вычисляет сумму произведений двух параллельных значений векторов (цена*кол-во_товара)
//На вход: константная ссылки на 2 непустых вектора равных по размерам
//Возврат: сумма произведений двух параллельных значений векторов (price[i]*count[i])
{
	if (price.size()==0 || count.size()==0)
		error ("пустой вектор (common_chek)!!!");
	else if (price.size() != count.size())
		error ("размеры векторов 'цена' и 'кол-во (вес) товара' не равны (common_chek)!!!");
		
	double summ = 0;
	for (int i = 0;  i < price.size(); ++i)
		summ += price[i]*count[i];
	
	if (isinf(summ))
		error ("общая сумма чека вышла за пределы типа DOUBLE (common_chek)!!!");
	else
		return summ;
}

//------------------------------------------------------------------------------

void print_vdouble(const string& s, const vector<double>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;
	
	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

//------------------------------------------------------------------------------

void print_vint(const string& s, const vector<int>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;
	
	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

void print_vstr(const string& s, const vector<string>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;
	
	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

//------------------------------------------------------------------------------

vector<int> vector_int1 (vector<int> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд вектор
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1
	
	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);
	
	return v;
}

void vector_int2 (vector<int>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0
	
	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------

vector<string> vector_str1 (vector<string> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд вектор
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1
	
	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);
	
	return v;
}

void vector_str2 (vector<string>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0
	
	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------

vector<double> vector_double1 (vector<double> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд векторы
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1
	
	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);
	
	return v;
}

void vector_double2 (vector<double>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0
	
	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------
