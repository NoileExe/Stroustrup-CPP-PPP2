#include "vectors.h"

void my_error (string error_str)
{
	try		{ throw 'e'; }

	catch (...) {
		cerr << "Ошибка: " << error_str << '\n';

		while (cin.get() != '\n') cin.clear(); //Очищает поток символов cin

		keep_window_open("~~");
		throw;
	}
}

//------------------------------------------------------------------------------

struct_minmaxmid search_4m (const vector<double>& v)
//Инициализирует структуру struct_minmaxmid состоящую из 4 переменных double
//по сути вычисляет для непустого ветора мин., макс. числа, среднее арифм. и медиану
{
	struct_minmaxmid s_mmmm;

	if (v.size()==0)
		my_error ("пустой вектор (search_4m)!!!");

	s_mmmm.min = minv_proc(v);
	s_mmmm.max = maxv_proc(v);
	s_mmmm.mid = midv_proc(v);
	s_mmmm.medi = mediv_proc(v);

	return s_mmmm;
}

//------------------------------------------------------------------------------

double minv_proc(const vector<double>& v)
//Поиск наименьшего элемента в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: наименьший элемент в векторе
{
	if (v.size()==0)
		my_error ("пустой вектор (minv)!!!");

	double min = v[0];
	for (int i = 0;  i < v.size(); ++i)
		if (v[i] < min)
			min = v[i];

	return min;
}

double maxv_proc(const vector<double>& v)
//Поиск наибольшего элемента в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: наибольший элемент в векторе
{
	if (v.size()==0)
		my_error ("пустой вектор (maxv)!!!");

	double max = v[0];
	for (int i = 0;  i < v.size(); ++i)
		if (v[i] > max)
			max = v[i];

	return max;
}

double midv_proc(const vector<double>& v)
//Вычисление среднего арифметического для ряда чисел в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: среднее арифметическое
{
	if (v.size()==0)
		my_error ("пустой вектор (midv)!!!");

	double middle = 0;
	for (int i = 0;  i < v.size(); ++i)
		middle += v[i];

	middle /= v.size();

	if (isinf(middle))
		my_error ("значение вышло за пределы типа DOUBLE (midv)!!!");
	else return middle;
}

double mediv_proc(vector<double> v)
//Вычисление медианы для ряда чисел в векторе
//На вход: непустой вектор (копия)
//Возврат: медиана
{
	if (v.size()==0)
		my_error ("пустой вектор (mediv)!!!");

	sort( v.begin(), v.end() );

	double median = 0;
	int mid = int( v.size() / 2 );
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)

	if (v.size()%2 == 0) //четное кол-во элементов в векторе
		median = (v[mid]+v[mid+1])/2;
	else median = v[mid];

	if (isinf(median))
		my_error ("значение вышло за пределы типа DOUBLE (mediv)!!!");
	else return median;
}

//------------------------------------------------------------------------------

double common_check (const vector<double>& price, const vector<double>& count)
//вычисляет сумму произведений двух параллельных значений векторов (цена*кол-во_товара)
//На вход: константная ссылки на 2 непустых вектора равных по размерам
//Возврат: сумма произведений двух параллельных значений векторов (price[i]*count[i])
{
	if (price.size()==0 || count.size()==0)
		my_error ("пустой вектор (common_chek)!!!");
	else if (price.size() != count.size())
		my_error ("размеры векторов 'цена' и 'кол-во (вес) товара' не равны (common_chek)!!!");

	double summ = 0;
	for (int i = 0;  i < price.size(); ++i)
		summ += price[i]*count[i];

	if (isinf(summ))
		my_error ("общая сумма чека вышла за пределы типа DOUBLE (common_chek)!!!");
	else return summ;
}

//------------------------------------------------------------------------------

void print_until_s (const vector<string>& v, string quit)
//выводит на экран элементы вектора по ссылке пока не встретит элемент вектора
//равный строке quit
{
	if (v.size()==0)
		my_error ("пустой вектор ( print_until_s() )!!!");

	else
		cout << "Вектор из " << v.size() << " элем. до завершающего слова '"
			 << quit << "': " << endl;

	for (int i = 0;  i < v.size(); ++i) {
		if ( i < (v.size()-1) )
			cout << "[" << i+1 << "] " << v[i] << endl;
		else
			cout << "[" << i+1 << "] " << v[i] << "\n\nСтоп-слово не встечено ;)\n\n";
		
		if (v[i] == quit)	return;
	}
}

void print_until_ss (const vector<string>& v, string quit, int k)
//выводит на экран элементы вектора по ссылке пока не встретит k раз элемент
//вектора равный строке quit
{
	if (v.size()==0)
		my_error ("пустой вектор ( print_until_ss() )!!!");
	else
		cout << "Вектор из " << v.size() << " элем. до втречи " << k << "й раз "
				 "завершающего слова '" << quit << "': " << endl;

	int n = 0; //Подсчёт того сколько раз было встречено завершающее слово
	for (int i = 0;  i < v.size(); ++i) {
		if ( i < (v.size()-1) )
			cout << "[" << i+1 << "] " << v[i] << endl;
		else
			cout << "[" << i+1 << "] " << v[i] << "\n\nСтоп-слово " << k << "й раз "
				     " не встечено. Стоп-слово было встречено " << n << " раз.\n\n";
		
		if (v[i] == quit && n == k-1)	return;
		else if (v[i] == quit)			++n;

		
	}
}

//------------------------------------------------------------------------------

void print_vdouble(const string& s, const vector<double>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;

	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

void print_vint(const string& s, const vector<int>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;

	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

void print_vstr(const string& s, const vector<string>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;

	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

//------------------------------------------------------------------------------

vector<int> vector_int1 (vector<int> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд вектор
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1

	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);

	return v;
}

void vector_int2 (vector<int>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0

	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------

vector<string> vector_str1 (vector<string> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд вектор
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1

	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);

	return v;
}

void vector_str2 (vector<string>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0

	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------

vector<double> vector_double1 (vector<double> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд векторы
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1

	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);

	return v;
}

void vector_double2 (vector<double>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0

	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------
