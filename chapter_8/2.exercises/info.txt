1. Модифицируйте программу-калькулятор из главы 7, чтобы поток ввода стал явным параметром (как показано в разделе 8.5.8). Кроме того,
напишите конструктор масса Token_stream (раздел 7.8.2) с параметром istream& так, чтобы, когда вы поймете, как создавать собственные потоки ввода и вывода (например, подключать файлы), вы смогли
бы использовать калькулятор с ними. Указание: не пытайтесь копировать istream.

2. Напишите функцию print(), которая выводит в поток cout вектор целых чисел. Передавайте ей два аргумента: строку для "метки" результатов и объект vector.

3. Создайте вектор чисел Фибоначчи и выведите их на печать с помощью функции из упр.2. Для того чтобы создать вектор, напишите функцию fibonacci(х,у,v,n), в которой аргументы х и у имеют тип int, аргумент v представляет собой пустой vector<int>,
а аргумент n - количество элементов, подлежащих записи в вектор v: элемент v[0] будет равен х, а v[1] - у.
Число Фибоначчи - это элемент последовательности, в которой каждый элемент является суммой двух предыдущих. Например, если последовательность начинается с чисел 1 и 2, то мы получаем последовательность 1, 2, 3, 5, 8, 13, 21 , ... . Функция fibonacci() должна генерировать такую последовательность, начинающуюся с чисел х и у.

4. Переменная типа int может хранить целые числа, не превышающие некоторого максимального числа. Вычислите приближение этого максимального числа с помощью функции fibonacci().

5. Напишите две функции, обращающие порядок следования элементов в объекте типа vector<int>. Например, вектор 1, 3, 5, 7, 9 становится вектором 9, 7, 5, 3, 1. Первая функция, изменяющая порядок следования элементов на противоположный, должна создавать новый объект класса vector, а исходный объект класса vector должен оставаться неизменным. Другая функция должна изменять порядок следования элементов в передаваемом ей векторе без использования других векторов. Указание: воспользуйтесь функцией swap.

6. Напишите варианты функций из упражнения 5 для класса vector<string>.

7. Считайте пять имен в вектор vector<string> name, затем предложите пользователю указать возраст названных людей и запишите их в вектор vector<double> age. Затем выведите на печать пять пар (name[i], age[i]). Отсортируйте имена ( sort(name.begin(), name.end()) ) и выведите на экран пары (name[i], age[i]). Сложность здесь заключается в том, чтобы получить вектор age, в котором порядок следования элементов соответствовал бы порядку следования элементов вектора name. Указание: перед сортировкой вектора name создайте его копию и используйте ее для получения упорядоченного вектора age после сортировки вектора name. Затем выполните упражнение снова, разрешив использование произвольного количества имен.

8. Напишите функцию, которая для двух данных объектов типа vector<double> price и weight, вычисляет значение равное сумме всех произведений price[i]*weight[i]. Проверьте выполнение условия weight.size() == price.size().

9. Напишите функцию maxv(), возвращаюшую наибольший элемент вектора, передаваемого в качестве аргумента.

10. Напишите функцию, которая находит наименьший и наибольший элементы вектора, являющегося ее аргументом, а также вычисляющую их среднее и медиану. Не используйте глобальные переменные. Результаты можно вернуть либо в виде структуры struct, либо с помощью механизма передачи аргументов по ссылке. Какой из этих двух способов следует предпочесть и почему?

11. Усовершенствуйте функцию print_until_s() из раздела 8.5.2. Протестируйте ее. Какие наборы данных лучше всего подходят для тестирования? Укажите причины. Затем напишите функцию print_until_ss(), которая выводит строки, пока не обнаружит второе вхождение строки аргумента quit.

12. Напишите функцию, принимающую аргумент типа vector<string> и возвращающую объект типа vector<int>, содержащий количество символов в каждой строке. Кроме того, найдите самую короткую и самую длинную строки, а также лексикографически первую и последнюю строки. Сколько отдельных функций вы использовали бы для решения этих задач? Почему?

13. Можно ли объявить константный аргумент функции, который передается не по ссылке (например, void f(const int);)? Что это значит? Зачем это нужно? Почему такая конструкция практически не применяется? Испытайте ее; напишите несколько маленьких программ, чтобы увидеть, как она работает