#include <std_lib_facilities.h>

//------------------------------------------------------------------------------

double maxv(const vector<double>& v)
//Поиск наибольшего элемента в векторе
//На вход: константная ссылка на непустой вектор
//Возврат: наибольший элемент в векторе
{
	if (v.size()==0)
		error ("пустой вектор (maxv)!!!");
	
	double max = v[0];
	for (int i = 0;  i < v.size(); ++i)
		if (v[i] > max)
			max = v[i];
	
	return max;
}

//------------------------------------------------------------------------------

double common_check (const vector<double>& price, const vector<double>& count)
//вычисляет сумму произведений двух параллельных значений векторов (цена*кол-во_товара)
//На вход: константная ссылки на 2 непустых вектора равных по размерам
//Возврат: сумма произведений двух параллельных значений векторов (price[i]*count[i])
{
	if (price.size()==0 || count.size()==0)
		error ("пустой вектор (common_chek)!!!");
	else if (price.size() != count.size())
		error ("размеры векторов 'цена' и 'кол-во (вес) товара' не равны (common_chek)!!!");
		
	double summ = 0;
	for (int i = 0;  i < price.size(); ++i)
		summ += price[i]*count[i];
		
	if (isinf(summ))
		error ("общая сумма чека вышла за пределы типа DOUBLE (common_chek)!!!");
	else return summ;
}

//------------------------------------------------------------------------------

void print_vdouble(const string& s, const vector<double>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;
	
	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

//------------------------------------------------------------------------------

void print_vint(const string& s, const vector<int>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;
	
	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

void print_vstr(const string& s, const vector<string>& v)
//На вход константные ссылки на строку и вектор
//Вывод на экран строку в виде: "ПЕРЕДАННАЯ_СТРОКА (РАЗМЕР_ВЕКТОРА):"
//и далее каждый элемент вектора на новой строке в виде: [ИНДЕКС] ЭЛЕМЕНТ_ВЕКТОРА
{
	cout << s << " (" << v.size() << "): " << endl;
	
	for (int i = 0;  i < v.size(); ++i)
		if ( i < (v.size()-1) ) cout << "[" << i << "] " << v[i] << endl;
		else					cout << "[" << i << "] " << v[i] << "\n\n";
}

//------------------------------------------------------------------------------

vector<int> vector_int1 (vector<int> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд вектор
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1
	
	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);
	
	return v;
}

void vector_int2 (vector<int>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0
	
	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------

vector<string> vector_str1 (vector<string> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд вектор
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1
	
	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);
	
	return v;
}

void vector_str2 (vector<string>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0
	
	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------

vector<double> vector_double1 (vector<double> v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
//Возврат: перебранный задом наперёд векторы
{
	int mid = int(v.size()/2);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 1
	
	for (int i = 0;  i < mid; ++i)
		swap(v[i],v[v.size()-i-1]);
	
	return v;
}

void vector_double2 (vector<double>& v)
//сортирует вектор задом наперёд (последний элемент становится первым, а первый -
// последним и т.д.)
//На вход: вектор (копия)
{
	int mid = int( (v.size()/2) - 1);
	//срединный элемент (или 1ый срединный если четное кол-во эл. в векторе)
	//при счете порядковых номеров от 0
	
	for (int i = 0;  i <= mid; ++i)
		swap(v[i],v[v.size()-i-1]);
}

//------------------------------------------------------------------------------
