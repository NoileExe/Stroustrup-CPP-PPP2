1. Аргументы функции f в выражениях a.apply(f) и apply(f, a) являются разными. Напишите функцию triple() для каждого варианта и примените их для утроения элементов массива { 1 2 З 4 5 }. Определите единую функцию triple(), которую можно было бы использовать как в выражении a.apply(triple), так и в выражении apply(triple, a).
Объясните, почему писать для использования в качестве аргумента функции apply() все функции именно таким образом - плохая идея.

2. Повторите упр. 1, используя не функции, а функциональные объекты. Указание: примеры можно найти в заголовочном файле Маtrix.h.

3. Только для экспертов (средствами, описанными в книге, эту задачу решить невозможно). Напишите функцию apply(f, а), принимающую в качестве аргумента функции void(T&), T(const T&), а также эквивалентные им функциональные объекты. Указание: см. boost::bind.

4. Выполните программу метода исключения Гаусса, т.е. завершите ее, скомпилируйте и протестируйте на простом примере.

5. Примените программу метода исключения Гаусса к системе А=={ { 0 1 } { 1 0 } } и b= { 5 6 } и убедитесь, что программа не в состоянии найти решение. Затем попробуйте применить в ней функцию elim_with_partial_pivot().

6. Замените циклами векторные операции dot_product() и scale_and_add() в программе метода исключения Гаусса. Протестируйте и прокомментируйте эту программу.

7. Перепишите программу метода исключения Гаусса без помощи библиотеки Matrix. Иначе говоря, используйте встроенные массивы или класс vector, но не класс Matrix.

8. Анимируйте метод исключения Гаусса.

9. Перепишите функцию apply(), не являющуюся членом класса Matrix, так, чтобы она возвращала объект класса Matrix, элементы которого имели бы тип возврата примененной функции. Иначе говоря, функция apply(f ,а) должна возвращать объект класса Matrix<R>, где R - тип возвращаемого функцией f значения. Предупреждение: это решение требует информации о шаблонах, которая в данной книге отсутствует.

10. Насколько случайным является механизм default_random_engine? Напишите программу, принимающую два целых числа n и d из потока ввода, d раз вызывающую функцию randint(n) и записывающую результат. Выведите на экран количество каждого из выпавших чисел из диапазона [0,n) и оцените, насколько одинаковым является их количество. Выполните программу с небольшими значениями n и небольшими значениями d, чтобы убедиться в том, что очевидные перекосы возникают только при небольшом количестве испытаний.

11. Напишите функцию swap_columns(), аналогичную функции swap_rows() из раздела 24.5.3. Очевидно, что для этого необходимо изучить код библиотеки Matrix. Не беспокойтесь об эффективности своей программы: быстродействие функции swap_columns() в принципе не может превышать быстродействие функции swap_rows().

12. Реализуйте операторы
Matrix<double> operator*(Matrix<double, N>&, Matrix<double, N>&);
и
Matrix<double, N> operator+(Matrix<double, N>&, Matrix<double, N>&)
При необходимости посмотрите их математические определения в учебниках.