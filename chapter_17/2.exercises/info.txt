1. Какой формат вывода значений указателей в вашей реализации языка? Указание: не читайте документацию.

2. Сколько байтов занимают типы int, double и bооl? Ответьте на вопрос, не используя оператор sizeof, разве что для проверки вашего ответа.

3. Напишите функцию void to_lower(char* s), заменяющую все прописные символы в С-строке s их строчными эквивалентами. Например, строка "Hello, World!" должна принять вид "hello, world!". Не используйте стандартные библиотечные функции. С-строка представляет собой массив символов, который завершается нулем, поэтому если вы обнаружите символ 0, то это значит, что вы находитесь в конце массива.

4. Напишите функцию "char* strdup (const char*)", копирующую С-строку в выделенную в динамической памяти строку. Не используйте стандартные библиотечные функции.

5. Напишите функцию "char* findx(const char* s, const char* х)", находящую первое вхождение С-строки х в строку s.

6. В этой главе ничего не говорилось о том, что произойдет, если, используя оператор new, вы столкнетесь с нехваткой памяти. Это называется исчерпанием памяти (memory exhaustion). Выясните, что случится. У вас есть две очевидные альтернативы: обратиться к документации или написать программу с бесконечным циклом, в котором происходит многократное выделение памяти и не выполняется ее освобождение. Попробуйте оба варианта. Сколько примерно памяти вы сможете выделить, пока она не исчерпается?

7. Напишите программу, считывающую символы из потока cin в массив, выделенный в динамической памяти. Читайте отдельные символы, пока не встретится восклицательный знак (!). Не используйте класс std::string и не беспокойтесь об исчерпании памяти.

8. Выполните упр.7 еще раз, но теперь считывайте символы в строку std::string, а не в динамическую память (класс string знает, как использовать динамическую память).

9. Как увеличивается стек: вверх (в сторону старших адресов) или вниз (в сторону младших адресов)? В каком направлении изначально (пока не было выполнено ни одного освобождения) растет выделяемая память? Напишите программу, позволяющую выяснить это.

10. Посмотрите на решение упр.7. Может ли ввод вызвать переполнение массива; иначе говоря, можете ли вы ввести больше символов, чем выделено памяти (это серьезная ошибка)? Что произойдет, если вы попытаетесь ввести больше символов, чем выделено памяти? (ФАЙЛ "10.txt" лежит рядом с исходником и должен находится рядом с исполняемым файлом перед его запуском)

11. Завершите программу из раздела 17.10.1 , создающую "список богов".

12. Зачем нужны две версии функции find()?

13. Модифицируйте класс Link из раздела 17.10.1, чтобы он хранил значение struct God. Этот тип должен иметь члены типа string: имя, мифология, транспортное средство и оружие. Например, "God{ "Зевс", "Греция", "", "Молния" }" или "God{ "Один", "Норвегия", "Восьминогий летающий конь Слейпнер" , "Копье Гунгнир" }".  Напишите функцию print_all(), построчно выводящую имена богов и их атрибуты. Добавьте функцию-член add_ordered(), размещающую новый элемент, создаваемый с помощью оператора new, в правильной лексикографической позиции. Используя объекты Link со значениями типа God, составьте список богов из трех мифологий: затем переместите элементы (богов) из этого списка в три лексикографически упорядоченных списка - по одному для каждой мифологии.

14. Можно ли написать список богов из раздела 17.10.1 в виде односвязного списка: другими словами, можно ли удалить член prev из класса Link? По каким причинам мы могли бы это сделать? В каких ситуациях разумно использовать односвязные списки? Переделайте такой пример с использованием только односвязного списка.