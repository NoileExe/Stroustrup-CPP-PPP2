1. Рассмотрим еще один способ определения функции, вычисляющей факториал.

int fac(int n) { return n>1 ? n*fac(n-1) : 1; } // n!

При вычислении, например, fac(4), эта функция сначала выясняет, что, поскольку 4 > 1, ответ равен "4*fac(3)", что, очевидно, равно "4*3*fас(2)" или, рассуждая аналогично, "4*3*2*fac(1)", т.е. "4*3*2*1". Попытайтесь понять, как работает эта функция. Функция, вызывающая саму себя, называется рекурсивной (recursive). Альтернативная реализация, описанная в разделе 15.5, называется итеративная (iterative), потому что в ней используется итерация по значениям (в цикле while).
Убедитесь, что рекурсивная функция fac() работает и выдает те же результаты, что и итеративная функция fac() при вычислении факториала чисел 0, 1 , 2, 3, 4 и так далее до 20. Какую реализацию функции fac() вы предпочитаете и почему?

2. Определите класс Fct, который почти совпадает с классом Function, за исключением того, что он хранит аргументы, переданные конструктору. Включите в класс Fct операции "восстановления" параметров, чтобы мы могли повторять вычисления с разными диапазонами, функциями и т.д.

3. Модифицируйте класс Fct из предыдущего упражнения так, чтобы в нем был дополнительный аргумент, позволяющий контролировать точность. Сделайте тип этого аргумента шаблонным параметром, чтобы повысить гибкость класса.

4. Постройте графики функций sin(), cos(), sin(х) + cos(х) и  sin(х) * sin(х) + cos(х) * cos(х) на одном рисунке. Изобразите оси и метки.

5. "Анимируйте" (как в разделе 15.5) ряд 1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + ... Он называется рядом Лейбница (Leibniz) и сходится к числу pi/4.

6. Разработайте и реализуйте класс для построения гистограммы. Его исходные данные должны храниться в векторе типа vector<double>, в котором записаны N значений и каждое значение представляется "столбиком", т.е. прямоугольником с соответствующей высотой.

7. Разработайте класс для построения гистограмм, позволяющий расставлять метки на рисунке в целом и на отдельных столбиках в частности. Предусмотрите использование цвета.

8. Ниже перечислено множество пар, составленных из роста и количества людей указанного роста (с точностью до пяти сантиметров): (170,7), (175,9), (180,23), (185, 17), (190,6), (195, 1). Как изобразить эти данные? Если вы не нашли лучшего решения, постройте гистограмму. Помните об осях и метках. Запишите данные в файл и считайте их оттуда. (ФАЙЛ "8.txt" лежит рядом с исходником задачи и требуется для ее тестирования)

9. Найдите другой набор данных о росте людей и изобразите их с помощью программы, созданной при выполнении предыдущего упражнения. Например, найдите в вебе распределение роста людей в CШA или попросите своих друзей измерить свой рост. В идеале вы не должны изменять свою программу, чтобы приспособить ее к новому набору данных. Для этого следует применить масштабирование данных. Считывание меток также позволит минимизировать количество изменений, если вы захотите повторно использовать программу. (ФАЙЛ "9.txt" лежит рядом с исходником задачи и требуется для ее тестирования)

10. Какие виды данных неудобно представлять с помощью графиков или гистограмм? Найдите пример и опишите способ представления таких данных (например, в виде коллекции помеченных точек

11. Найдите среднюю температуру для каждого месяца в нескольких городах (например, Кембридж, Англия и Кембридж, Массачусетс; в мире есть много городов с названием "Кембридж") и изобразите их на одном рисунке. Как всегда, помните об осях, метках, цвете и т.д. (ФАЙЛЫ "minvody.txt", "sochi.txt" и "spb.txt" лежат рядом с исходником задачи и требуются для ее успешного тестирования/запуска (должны лежать в директории с итоговым исполняемым файлом))