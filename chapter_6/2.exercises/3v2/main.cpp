// calculator01.cpp

#include <yes_or_no.h>
#include <console_encoding.h>
#include <std_lib_facilities.h>

class Token {
public:
	char kind;		//что за символ
	double value;	 //для чисел: значение 
	Token(char ch)	//объект класса Token из символа
		:kind(ch), value(0) { }
	Token(char ch, double val)	 //объект класса Token из символа и числа double
		:kind(ch), value(val) { }
};

//------------------------------------------------------------------------------

class Token_stream {
public:
	Token_stream();   //создаём Token_stream который читает из потока ввода cin
	Token get();	  //получаем объект Token (член get() определен в другом месте)
	void putback(Token t);	//возврат Token обратно в ф-цию (в буфер)
private:
	//bool Token_stream::full{ false };		// is there a Token in the buffer?
	bool full;
	Token buffer;	 //здесь сохраняем объект класса Token, помещённый обратно,
														// используя putback ()
};

//------------------------------------------------------------------------------

//Конструкция, которая просто делает буфер пустым изначально:
Token_stream::Token_stream()
	:full(false), buffer(0)	//нет объекта Token в буфере
{
}

//------------------------------------------------------------------------------

//Член putback() помещает аргумент в буфер своей ф-ции Token_stream:
void Token_stream::putback(Token t)
{
	if (Token_stream::full)
		error("Ошибка ф-ции putback(): попытка заполнить уже полный буфер");

	Token_stream::buffer = t;	   //копировать t в буфер
	Token_stream::full = true;	  //теперь буфер полон
}

//------------------------------------------------------------------------------

int num_of_symb = 0; //Чтобы отслеживать первый символ в строке или нет
int brace = 0; /*фигурная скобка используется для визуального отличия от круглой
(если скобки в скобках), потому если выражение в {} не содержит выражения в () - ОШИБКА*/

//------------------------------------------------------------------------------

double expression(); //объявляем, т.к. ф-ция primary() может вызвать expression()
double primary(); //объявляем, т.к. функция-член Token_stream::get() может вызвать primary()

//------------------------------------------------------------------------------

Token Token_stream::get()
{
	if (Token_stream::full == true) { //Если в буфере уже имеется объект типа Token..
		//..удаляем его из буфера (помечаем буфер как пустой, т.е. доступный для перезаписи)
		Token_stream::full = false;
		return Token_stream::buffer;
	}

	char ch;
	cin >> ch;	//замечание: оператор >> пропускает пустые пространства
				 //(пробел, символ новой строки, табуляция и т.д.)

	if (cin.eof()) {
		string error_str = "CTRL+Z";
		throw   runtime_error(error_str); //Закрыть программу? Да или Нет (д / н)
	}

	switch (ch) {

		case 'x': {
			string error_str = "Выход";
			throw   runtime_error(error_str); //для немедленного выхода
		}

		case '=':	//для завершения вычислений и немедленного вывода ответа на экран
		case '!':
		case ')': case '}': case '+': case '*': case '/': case '%':
			return Token(ch);		//возвращаем символ как есть

		case '(':
			brace = 1; //Покажет что внутри {} скобок присутствуют вложенные круглые
						//Иначе если круглые скобки являются вложенными, при значении 0 - ошибка
			num_of_symb = 0; //После скобки может идти отриц. число, напр., "(-1+3)"
							 //и по логике программы оно должно "считаться" 1ым в строке
			return Token(ch);

		case '{':
			brace = 0; //Покажет что внутри {} скобок отсутствуют вложенные круглые
			num_of_symb = 0; //После скобки может идти отриц. число, напр., "{-1*(2+3)}"
							 //и по логике программы оно должно "считаться" 1ым в строке
			return Token(ch);

		case '-':
		{
			if (num_of_symb == 0) //Если считывается первое число в выражении
			{
				double val;

				cin >> ch;
				cin.putback(ch);		 //возвращаем символ обратно в потом ввода
				num_of_symb = 1;		 //помечаем что 1ое число в строке уже имеется

				if (ch == '(' || ch == '{') //решение проблемы: -(2+3)= И -(3)= выдает ошибку, хотя 1-(2+3)= не выдает
					val = primary(); //вычисляем в скобках число с плавающей ЗПТ
				else if (ch >= '0' || ch <= '9')
					cin >> val; //считываем число с плавающей ЗПТ

				return Token('8', -val); //помечаем объект символом '8' означающим "число"
			}
			else   return Token(ch); //возвращаем символ как есть
		}

		case '.':
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		{
			cin.putback(ch);		 //возвращаем символ обратно в потом ввода
			num_of_symb = 1;		//помечаем что 1ое число в строке уже имеется
			double val;
			cin >> val;				//считываем число с плавающей ЗПТ
			return Token('8', val);	//помечаем объект символом '8' означающим "число"
		}

		default: {
			string error_str = "недопустимый ввод ( Token_stream::get() )";
			throw   runtime_error(error_str);
		}

	}
}

//------------------------------------------------------------------------------

Token_stream ts; //обеспечивает работу с членами ф-ции get() и putback()

//------------------------------------------------------------------------------

double fact(double num) //Вычисление факториала. На вход только целые числа
{
	double answer = 1;

	if ( int(num) != num )
	{
		string error_str = "факториал должен быть от ЦЕЛОГО числа ( fact() )";
		throw   runtime_error(error_str);
	}
	
	else if (num < 0)
	{
		answer *= -1;
		num *= -1; //Чтобы возвращаемое значение было отрицательным
	}
	else if (num == 0)
		return answer; //Факториал нуля равен единице

	if (num - int(num) == 0) //Число целое?
		for (int i = 1; i <= num; ++i)
			answer *= i;

	return answer;
}

//------------------------------------------------------------------------------

//обработка чисел, двух видов скобок и факториала
double primary()
{
	/*Выражение:
							Терм
							Выражение + Терм
							Выражение - Терм
	  Терм:
							Первичное_Выражение
							Терм * Первичное_Выражение
							Терм / Первичное_Выражение
							Терм % Первичное_Выражение
	  Первичное_Выражение:
							Число
							Первичное_Выражение !
							( Выражение )
							( Выражение ) !
							{( Выражение )}
							{( Выражение )} !
	  Число:
							Литерал_с_плавающей_точкой  */

	Token t = ts.get();
	
	switch (t.kind) {

		case '(':	//регулирует конструкцию '(' выражение ')'
		{
			//brace = 1;
			double d = expression();
			t = ts.get();

			if (t.kind != ')') {
				string error_str = "ожидалась закрывающая скобка - ')' ( primary() )";
				throw   runtime_error(error_str);
			}

			//Обнаружение и вычисление факториала
			t = ts.get(); //записываем в t новое значение
			if (t.kind == '!') d = fact(d); //Пробуем вычислить факториал числа
			else if (t.kind != '8') cin.putback(t.kind); //ts.putback(t); //Возвращаем символ в поток токенов, иначе потеряется

			return d;
		}

		case '{':	//регулирует конструкцию '{' '(' выражение ')' '}'
		{
			//brace = 0;
			double d = expression();
			t = ts.get();

			if (t.kind != '}') {
				string error_str = "ожидалась закрывающая скобка - '}' ( primary() )";
				throw   runtime_error(error_str);
			}
			
			//Не было обнаружено вложенных круглых скобок, напр., {2+1}
			else if (brace == 0) {
				string error_str = "ожидалось выражение в '(' и ')' внутри выражения"
									" в '{' и '}' ( primary() )";
				throw   runtime_error(error_str);
			}

			//Обнаружение и вычисление факториала
			t = ts.get(); //записываем в t новое значение
			if (t.kind == '!') d = fact(d); //Пробуем вычислить факториал числа
			else if (t.kind != '8') cin.putback(t.kind); //Возвращаем символ в поток токенов, иначе потеряется

			return d;
		}

		case '8':			//символ '8' обозначает что объект является числом
		{
			double d = t.value; //получаем само число

			//Обнаружение и вычисление факториала
			t = ts.get(); //записываем в t новое значение
			if (t.kind == '!') d = fact(d); //Пробуем вычислить факториал числа
			else if (t.kind != '8') cin.putback(t.kind); //ts.putback(t); //Возвращаем символ в поток токенов, иначе потеряется

			return d;  //возвращаем значение числа
		}

		case '=': //Помогает избежать ошибки если первое число в выражении отрицательное
			cin.putback(t.kind);
			return 0;

		default: {
			string error_str = "ожидалось первичное выражение ( primary() )";
			throw   runtime_error(error_str);
		}
	}
}

//------------------------------------------------------------------------------

//обработка операторов *, / и %
double term()
{
	double left = primary(); //считываем и вычисляем первичное_выражение
	Token t = ts.get();		//получаем след. объект token из потока token'ов

	while (true) {
		switch (t.kind) {

			case '*':
				left *= primary(); //вычисляем первичное_выражение и умножаем
				t = ts.get();
				break;

			case '/':
			{
				double d = primary();

				if (d == 0) {
					string error_str = "деление на нуль ( term() )";
					throw   runtime_error(error_str);
				}

				left /= d; //вычисляем первичное_выражение и делим
				t = ts.get();
				break;
			}

			case '%':
			{
				double d = primary();

				if (d == 0) {
					string error_str = "деление на нуль ( term() )";
					throw   runtime_error(error_str);
				}
				
				else if ((int(left) != left) || (int(d) != d)) {
					string error_str = "ожидалось целое число при вычислении остатка от "
									   "деления оператором '%' ( term() )";
					throw   runtime_error(error_str);
				}

				left = int(left) % int(d); //определяем первичное_выражение и вычисляем остаток отделения
				t = ts.get();
				break;
			}

			default:
				ts.putback(t);	 //возвращаем t обратно в поток token'ов
				return left;
		}
	}
}

//------------------------------------------------------------------------------

//обработка операторов + и -
double expression()
{
	double left = term();	  //считываем и вычисляем Term
	Token t = ts.get();		//получаем след. объект token из потока token'ов

	while (true) {
		switch (t.kind) {

			case '+':
				left += term();	//вычисляем Term и прибавляем
				t = ts.get();
				break;

			case '-':
				left -= term();	//вычисляем Term и отнимаем
				t = ts.get();
				break;

			default:
				ts.putback(t);	 //возвращаем t обратно в поток token'ов
				return left;	   //наконец: больше нет + или -: возвращаем ответ
		}
	}
}

//------------------------------------------------------------------------------

int main()
{
	ConsoleCP cp {};	//Включает русский если не включен в настройках компилятора
	
	cout << "Добро пожаловать в программу калькулятор 2019 по Бьярне Страуструпу.\n\n"
			"После знака '>' вводите выражение в формате указанном далее.\n"
			"Для завершения ввода (подтверждения) нажмите клавишу ENTER.\n\n"
			"Последний (знак равенства '=') - используется для завершения выраж"
			"ения и произведения вычисления. ВНИМАНИЕ! Если вы не введёте знак "
			"равенства вы не получите результата вычислений.\n\nЧисла могут быт"
			"ь с любым знаком, целыми и с десятичной частью (ТОЧКА - десятичный"
			" разделитель).\n\n"; //ПРИВЕТСТВИЕ И ИНСТРУКЦИИ

TryAgain:

	try
	{
		cout << "\nВводите выражения в формате: ЧИСЛО ОПЕРАТОР ЧИСЛО ЗНАК_РАВЕНСТВА.\n"
				"Доступные операции: +, -, *, /, % (остаток от деления целых), ( ),"
				" {()}, ЧИСЛО! (факториал); x - для быстрого выхода\nПример:\n> 2+(2*2)= \n\n"; //ИНСТРУКЦИИ

		double val = 0;
		cout << "\n\n> ";
		while (cin) {
			Token t = ts.get();
			
			if (t.kind == '=')		//для немедленной печати используем '='
			{
				cout << " = " << val << "\n\n> ";
				num_of_symb = 0;
			}
			else
				ts.putback(t);

			val = expression();
		}
	}

	catch (exception& e) { //Для системных исключений при работе с программой
		//Все предусмотренные ошибки И выход через CTRL+Z или немедленный через ввод 'x'
		string str;
		getline(cin, str);
		cin.clear();
		
		str = e.what();
		
		if ( str == "Выход" )
		{
			cerr << "Выход иницализирован пользователем.\n\n";
			press_Enter_key();
			return 0;
		}
		
		else if ( str != "CTRL+Z" )
			cerr << "Ошибка: " << str << "\n\n";

		num_of_symb = 0;

		if (Y_or_N("Хотите закрыть программу?"))
			return 1000; //1
		else
			goto TryAgain;
	}

	catch (...) { //Для непредвиденных исключений
		cerr << "Упс! Неизвестное исключение!\n";

		num_of_symb = 0;

		if (Y_or_N("Хотите закрыть программу?") == true )
			return 1001; //3
		else
			goto TryAgain;
	}
	
	cout << "\n\n";
	press_Enter_key();
	return EXIT_SUCCESS;
}

//------------------------------------------------------------------------------
