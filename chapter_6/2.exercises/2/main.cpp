// calculator01.cpp

#include <yes_or_no.h>
#include <console_encoding.h>
#include <std_lib_facilities.h>

//------------------------------------------------------------------------------
ConsoleCP cp {};	//Включает русский если не включен в настройках компилятора
//------------------------------------------------------------------------------

class Token {
public:
	char kind;		//что за символ
	double value;	 //для чисел: значение 
	Token(char ch)	//объект класса Token из символа
		:kind(ch), value(0) { }
	Token(char ch, double val)	 //объект класса Token из символа и числа double
		:kind(ch), value(val) { }
};

//------------------------------------------------------------------------------

class Token_stream {
public:
	Token_stream();   //создаём Token_stream который читает из потока ввода cin
	Token get();	  //получаем объект Token (член get() определен в другом месте)
	void putback(Token t);	//возврат Token обратно в ф-цию (в буфер)
private:
	//bool Token_stream::full{ false };		// is there a Token in the buffer?
	bool full;
	Token buffer;	 //здесь сохраняем объект класса Token, помещённый обратно,
														// используя putback ()
};

//Конструкция, которая просто делает буфер пустым изначально:
Token_stream::Token_stream()
:full(false), buffer(0)	//нет объекта Token в буфере
{
}

//Член putback() помещает аргумент в буфер своей ф-ции Token_stream:
void Token_stream::putback(Token t)
{
	if (Token_stream::full)
		error("Ошибка ф-ции putback(): попытка заполнить уже полный буфер");
	
	Token_stream::buffer = t;	   //копировать t в буфер
	Token_stream::full = true;	  //теперь буфер полон
}

//------------------------------------------------------------------------------

int num_of_symb = 0; //Чтобы отслеживать первый символ в строке или нет
int brace = 0; /*фигурная скобка используется для визуального отличия от круглой
(если скобки в скобках), потому если выражение в {} не содержит выражения в () - ОШИБКА*/

//------------------------------------------------------------------------------

Token Token_stream::get()
{
	if (Token_stream::full) {	   //Если в буфере уже имеется объект типа Token..
		//..удаляем его из буфера (помечаем буфер как пустой, т.е. доступный для перезаписи)
		Token_stream::full = false;
		return Token_stream::buffer;
	}

	char ch;
	cin >> ch;	//замечание: оператор >> пропускает пустые пространства
				 //(пробел, символ новой строки, табуляция и т.д.)
	
	if (cin.eof())   throw 99; //Закрыть программу? Да или Нет (д / н)

	switch (ch) {
	
		case 'x':  throw 100; //для немедленного выхода

		case '=':	//для завершения вычислений и немедленного вывода ответа на экран
		case ')': case '}': case '+': case '*': case '/':
			return Token(ch); //возвращаем символ как есть
		
		case '(': 
			brace = 1; //Покажет что внутри {} скобок присутствуют вложенные круглые
						//Иначе если круглые скобки являются вложенными, при значении 0 - ошибка
			num_of_symb = 0; //После скобки может идти отриц. число, напр., "(-1+3)"
							 //и по логике программы оно должно "считаться" 1ым в строке
			return Token(ch);
		
		case '{':
			brace = 0; //Покажет что внутри {} скобок отсутствуют вложенные круглые
			num_of_symb = 0; //После скобки может идти отриц. число, напр., "{-1*(2+3)}"
							 //и по логике программы оно должно "считаться" 1ым в строке
			return Token(ch);
	
		case '-':
		{
			if ( num_of_symb == 0 ) //Если считывается первое число в выражении
			{
				cin.putback(ch);		 //возвращаем символ обратно в потом ввода
				double val;
				cin >> val;			  //считываем отриц. число с плавающей ЗПТ
				return Token('8', val);  //помечаем объект символом '8' означающим "число"
			}
			else return Token(ch); //возвращаем символ как есть
		}

		case '.':
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		{
			cin.putback(ch);		 //возвращаем символ обратно в потом ввода
			num_of_symb = 1;		 //помечаем что 1ое число в строке уже имеется
			double val;
			cin >> val;			  //считываем число с плавающей ЗПТ
			return Token('8', val);  //помечаем объект символом '8' означающим "число"
		}

		default:
			throw 1; //cerr << "недопустимый ввод (#1)";

	}
}

//------------------------------------------------------------------------------

Token_stream ts;		//обеспечивает работу с членами ф-ции get() и putback()

//------------------------------------------------------------------------------

double expression();	//объявляем, т.к. ф-ция primary() может вызвать expression()

//------------------------------------------------------------------------------

//обработка чисел и двух видов скобок
double primary()
{
	/*Выражение:
							Терм
							Выражение + Терм
							Выражение - Терм
		Терм:
							Первичное_Выражение
							Терм * Первичное_Выражение
							Терм / Первичное_Выражение
							Терм % Первичное_Выражение
		Первичное_Выражение:
							Число
							( Выражение )*/
	Token t = ts.get();
	switch (t.kind) {
	
	case '(':	//регулирует конструкцию '(' выражение ')'
	{
		//brace = 1;
		double d = expression();
		t = ts.get();
		
		if (t.kind != ')')   throw 2;
		//cerr << "ожидалась закрывающая скобка - ')' (#2)";
		
		return d;
	}
	
	case '{':	//регулирует конструкцию '{' '(' выражение ')' '}'
	{
		//brace = 0;
		double d = expression();
		t = ts.get();
		
		if (t.kind != '}') throw 3;
		//"ожидалась закрывающая скобка - '}' (#3)	"
		else if (brace == 0) throw 4; //Не было обнаружено вложенных круглых скобок, напр., {2+1}
		//"ожидалось выражение в '(' и ')' внутри выражения в '{' и '}' (#4)"
		
		return d;
	}
	
	case '8':			//символ '8' обозначает что объект является числом
		return t.value;  //возвращаем значение числа
		
	case '=': //Помогает избежать ошибки если первое число в выражении отрицательное
		cin.putback(t.kind);
		return 0;
		
	case ')': //Помогает избежать ошибки
		cin.putback(t.kind);
		return 0;

	default: //cerr << "ожидалось первичное выражение (#5)";
		throw 5;
	}
}

//------------------------------------------------------------------------------

//обработка операторов * и /
double term()
{
	/*Выражение:
							Терм
							Выражение + Терм
							Выражение - Терм
		Терм:
							Первичное_Выражение
							Терм * Первичное_Выражение
							Терм / Первичное_Выражение
							Терм % Первичное_Выражение
		Первичное_Выражение:
							Число
							( Выражение )*/
							
	double left = primary(); //считываем и вычисляем первичное_выражение
	Token t = ts.get();		//получаем след. объект token из потока token'ов

	while (true) {
		switch (t.kind) {
		
		case '*':
			left *= primary(); //вычисляем первичное_выражение и умножаем
			t = ts.get();
			break;
		case '/':
		{
			double d = primary();
			
			if (d == 0)   throw 6; //cerr << "деление на нуль (#6)";
			
			left /= d; //вычисляем первичное_выражение и делим
			t = ts.get();
			break;
		}

		default:
			ts.putback(t);	 //возвращаем t обратно в поток token'ов
			return left;
		}
	}
}

//------------------------------------------------------------------------------

//обработка операторов + и -
double expression()
{
	/*Выражение:
							Терм
							Выражение + Терм
							Выражение - Терм
		Терм:
							Первичное_Выражение
							Терм * Первичное_Выражение
							Терм / Первичное_Выражение
							Терм % Первичное_Выражение
		Первичное_Выражение:
							Число
							( Выражение )*/
	
	double left = term();	  //считываем и вычисляем Term
	Token t = ts.get();		//получаем след. объект token из потока token'ов

	while (true) {
		switch (t.kind) {
		case '+':
			left += term();	//вычисляем Term и прибавляем
			t = ts.get();
			break;
		case '-':
			left -= term();	//вычисляем Term и отнимаем
			t = ts.get();
			break;

		default:
			ts.putback(t);	 //возвращаем t обратно в поток token'ов
			return left;	   //наконец: больше нет + или -: возвращаем ответ
		}
	}
}

//------------------------------------------------------------------------------

int first_or_not = 0; /*Чтобы отслеживать какой раз вызывается ф-ция main(),
 чтобы определить стоит ли выводить большое приветствие или короткую инструкцию
 (после ошибки или попытки выйти и возврате в программу путём отрицательного 
 ответа на вопрос о завершении программы)*/

//------------------------------------------------------------------------------

int main()
{
	while (true) {
		try
		{
			if (first_or_not == 0) //Если программа только запущенна
			{
				cout << "Добро пожаловать в программу калькулятор 2019 по Бьярне Страуструпу.\n\n"
						"После знака '>' вводите выражение в форме: ЧИСЛО ОПЕРАТОР ЧИСЛО ЗНАК_РАВЕНСТВА.\n"
						"Для завершения ввода (подтверждения) нажмите клавишу ENTER.\n\n"
						"Последний (знак равенства '=') - используется для завершения выраж"
						"ения и произведения вычисления. ВНИМАНИЕ! Если вы не введёте знак "
						"равенства вы не получите результата вычислений.\n\nЧисла могут быт"
						"ь с любым знаком, целыми и с десятичной частью (ТОЧКА - десятичный"
						" разделитель).\n\nДоступные операции: +, -, *, /, ( ), {()}; x - "
						"для быстрого выхода\n\nПример:\n> 2+(2*2)= "; //ПРИВЕТСТВИЕ И ИНСТРУКЦИИ
				first_or_not = 1;
			}
			else
				cout << "\nВводите выражения в форме: ЧИСЛО ОПЕРАТОР ЧИСЛО ЗНАК_РАВЕНСТВА."
						"\nДоступные операции: +, -, *, /, ( ), {()}; x - для быстрого выхода"
						"\nПример:\n> 2+(2*2)= "; //ИНСТРУКЦИИ

			double val = 0;
			cout << "\n\n> ";
			while (cin) {
				Token t = ts.get();

				if (t.kind == '=')		//для немедленной печати используем '='
				{
					cout << " = " << val << "\n\n> ";
					num_of_symb = 0;
				}
				else
					ts.putback(t);

				val = expression();
			}
		}
		catch (exception& e) { //Для системных исключений при работе с программой
			cerr << "error: " << e.what() << '\n';
			
			num_of_symb = 0;
			
			if (Y_or_N("Закрыть программу?"))	return 0; //1
		}
		catch (int a) {
		//Все предусмотренные ошибки И выход через CTRL+Z или немедленный через ввод 'x'
			string str;
			getline(cin, str);
			cin.clear();

			if (a < 10)			cerr << "Ошибка: ";

			if (a == 1)			cerr << "недопустимый ввод (#1)	 ";
			else if (a == 2)	cerr << "ожидалась закрывающая скобка - ')' (#2)	 ";
			else if (a == 3)	cerr << "ожидалась закрывающая скобка - '}' (#3)	 ";
			else if (a == 4)	cerr << "ожидалось выражение в '(' и ')' внутри выражения"
										 << " в '{' и '}' (#4)	 ";
			else if (a == 5)	cerr << "ожидалось первичное выражение (#5)	 ";
			else if (a == 6)	cerr << "деление на нуль (#6)	 ";
			else if (a == 99)	; //Если введено CTRL+Z - ничего не делаем и просто задаем вопрос...
			else if (a == 100)	return 0;
			
			num_of_symb = 0;
			
			if (Y_or_N("Закрыть программу?"))	return 0; //2
		}
		catch (...) { //Для непредвиденных исключений
			cerr << "Упс! Неизвестное исключение!\n";
			
			num_of_symb = 0;
			
			if (Y_or_N("Закрыть программу?"))	return 0; //3
		}
	}
}

//------------------------------------------------------------------------------
