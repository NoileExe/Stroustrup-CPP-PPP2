//Первый прототип калькулятора с собственным (пользовательским) классом.
//Поддерживает 2 операции: + И *
//НЕ РАБОЧИЙ КОД!

#include <yes_or_no.h>
#include <std_lib_facilities.h>

//..............................................................................
ConsoleCP cp {};	//Включает русский если не включен в настройках компилятора
//..............................................................................
class Token
{
public:
	char kind;
	double value;
};
//..............................................................................
Token get_token(string); //Ф-ция чтения лексемы из потока cin
double conversion(string);  //Перевод строки в число
//..............................................................................
vector<Token> tok; //Сюда помещаем лексемы
//..............................................................................
int main()
{
	cout << "Простой калькулятор\nПоддерживает 2 операции: + И *\n\nВводите выр"
			"ажения в виде ЧИСЛО ОПЕРАНД ЧИСЛО... (напр., 1+7.8), подтверждая в"
			"вод клавишей Enter.\nКомбинация клавиш CTRL+Z для завершения прогр"
			"аммы\n\n";
	
	 double res; //результат вычислений
	 string input;
	
TryAgain:
	cout << "\n\nВведите выражение: ";
	
	getline(cin, input);
	
	if (get_token(input) != 'nan')
		tok = get_token(input);
	else if (!cin.eof())
		goto TryAgain;
	
	for (int i = 0; i < tok.size(); ++i)
	{
		if (tok[i].kind == '*') //Найдено умножение
			res = tok[i-1].value * tok[i+1].value;
		
		else if (tok[i].kind == '+')
			res = tok[i-1].value + tok[i+1].value;
	}
	
	cout << "Результат: " << res << "\n\n";
	
	tok.clear();
	
	if (!cin.eof())
		goto TryAgain;
	
	cout << "\n\n"; 
	press_Enter_key();
	return EXIT_SUCCESS;
}
//..............................................................................
Token get_token(string input) //Ф-ция чтения лексемы из потока cin
{
	if ( (input[0] != 45 && !(input[0] >= 48 && input[0] <= 57)) 
			|| (input[0] == 45 && !(input[1] >= 48 && input[1] <= 57)) 
			|| (!(input[input.size()-1] >= 48 && input[input.size()-1] <= 57)) )
			
	/*if ( (input[0] != '-' && !(input[0] >= '0' && input[0] <= '9')) 
			|| (input[0] == '-' && !(input[1] >= '0' && input[1] <= '9')) 
			|| (!(input[input.size()-1] >= '0' && input[input.size()-1] <= '9')) )*/
		return 'nan';
		
	int kordoper = 0;
	
	for (int i = 0; i < input.size(); ++i)
	{
		if ( (i == 0 && input[i] == 45) || (input[i] >= 48 && input[i] <= 57) 
				|| (i > 0 && input[i] == 46) )
	/*if ( (i == 0 && input[i] == '-') || (input[i] >= '0' && input[i] <= '9') 
				|| (i > 0 && input[i] == '.') )*/
			{ }
		else if ( i > 0 && (input[i] == '+' || input[i] == '*') )
		{
			
			
			if (conversion(input.substr(kordoper, i-1)) != 'nan')
				
			else
				return 'nan';
				
			kordoper = i+1;
		}
		else
			return 'nan';
		Token res;
	}
	
	/*while (cin)
	{
		getline(cin, input);
		Token t = get_token(input);
		tok.push_back(t);
	}
	
	if (isnan(input.value))
	{
		input.kind = input.value;
		input.value = 0;
	}
	else
		input.kind = '8';*/
		
}
//..............................................................................
double conversion(string str)
/*Проверяем допустимость ввода.
На ввод принимаем введённую пользователем строку.
При вводе считывается строка и посимвольно проверяет наличие недопустимых 
символов, а также проверяет не вышло ли число за диапазон DOUBLE*/
{
	double res = 0.0;
	int num_dot = 0; //Для подсчёта кол-ва точек и "координаты" (ск. символов до точки)
	
	//cout << setprecision(17); //Кол-во символов выводимых на экран у числа double
	
//Проверяем кол-во десятичных точек.............................................
	for (int i = 0; i < str.size(); ++i)
		if (str[i] == 46) //Если символ - точка..
			++num_dot; //.., то увеличиваем кол-во найденных на 1
	
	if (num_dot > 1 || str[0] == 46) //Если точек больше одной ИЛИ первый символ - точка..
		//cerr << "Введённое НЕ является ЧИСЛОм. Повторите ввод.\n\n";
		return 'nan'; //..сообщаем об ошике пользователю и процедуре вызвавшей ф-цию
	
	//Вычисляем сколько символов до точки, для перевода 10тичной части..........
	for (int i = 0; i < str.size() && num_dot > 0; ++i)
	{
		if (str[i] == 46) //Если символ - точка..
		{
			num_dot = i; //..запоминаем его координаты (индекс по счёту в строковой переменной)..
			break; //..завершаем цикл for
		}
	}
	//Вычисляем сколько символов до точки, для перевода 10тичной части..........
//Проверяем кол-во десятичных точек.............................................   
	
	for (int i = 0; i < str.size(); ++i)
	{
		if (i == 0 && str[i] == 45) { } //Если 1-ый -- минус, то ничего не делаем
			
		//i не первый И равен символу десятичной ЗПТ (".")
		else if ( i > 0 && i == num_dot && str[i] == 46) { } //Если НЕ 1-ый и яв-ся точкой, то ничего не делаем
				
		//если текущий символ проверяемой строки по таблице ASCII от 0 до 9
		else if (str[i] >= 48 &&  str[i] <= 57)
		{
			//Если число с десятичной ЗПТ (".")
			if (num_dot > 0)
			{
				if (i < num_dot) //Если переводим целую часть из строки в число
					res += (str[i]-48.0) * pow(10.0,( num_dot-i-1 ));
				else //Если переводим десятичную часть из строки в число
					res += (str[i]-48.0) * pow(10.0,( num_dot-i ));
			}
				
			//Если число целое
			else													//тек. индекс
								//число УМНОЖИТЬ на 10^ (длина строки - (i+1))
				res += (str[i]-48.0) * pow(10.0, ( str.size()-i-1 ));
				
		}
			
		else //Если символ не является ".", "-" или числом 0-9
		{
			cerr << "Введённое НЕ является ЧИСЛОм. Повторите ввод.\n\n";
			return 'nan';
			//Выдаём ошибку и возвращением значение, при котором далее 
			//происходит запрос на повторный ввод
		}
				
	}
//Посимвольно проверяем введёную строку на то число ли введено..................
		
	//Если 1ый символ -- минус, то делаем переведённое число отрицательным
	if (str[0] == 45)
		res *= (-1);
			
	//cout << str.size() << " " << res << '\n'; //ПРОВЕРКА ЧДС
	
	//Если ввели число которое при переводе выдаёт inf или -inf (+-бесконечность)
	if ( isinf(res) )
	{
		cerr << "\nВНИМАНИЕ! ОШИБКА!\nЗначение за пределами диапазона DOUBLE! "
				"Повторите ввод.\n\n";
		return 'nan';
		//Выдаём ошибку и возвращением значение, при котором далее 
		//происходит запрос на повторный ввод
	}
		
	return res; //Если всё допустимо - передаём данное число как корректно введённое
}
